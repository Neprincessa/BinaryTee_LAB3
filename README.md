# BinaryTee_LAB3
Тип дерева: «Бинарное дерево»

Обходы: ПКЛ,ЛКП

Типы хранимых данных:
1)	Студенты
2)	Преподаватели
С коллекцией «Строка» в данной программе возможно выполнение следующих функций:
1.	map (построить новое дерево поэлементным преобразованием)
2.	where (построить новое дерево, в которое входят лишь те узлы исходного, которые удовлетворяют заданному условию)
3.	Слияние
4.	Извлечение поддерева (по заданному элементу)
5.	Поиск на вхождение поддерева
6.	Поиск элемента на вхождение 
7.	Сохранение в строку в соответствии с заданным обходом
8.	Чтение из строки в соответствии с заданным обходом

Суть работы функций:

1)	Map. Пользователь получает на экране новое дерево, в котором все средние баллы студентов или стаж преподавателей заменены на 5
2)	Where. Пользователь получает новое дерево, куда записываются все студенты и преподаватели, у которых средний балл или стаж соответственно больше 25.
3)	 Слияние. Суть слияния состоит в том, что ко второму дереву добавляется первое
4)	Извлечение поддерева. Пользователь вводит средний балл студента или стаж преподавателя соответственно, и по нему происходит выделение поддерева из основного дерева.
5)	Поиск на вхождение поддерева. Создается дерево для поиска в основном дереве. Затем в основном дереве ищется совпадение с корнем искомого дерева. В положительном случае программа проверяет совпадение всех узлов правых и левых веток исходного дерева и маленького.
6)	Поиск элемента на вхождение. Программа ищет совпадение по среднему баллу для студента и по стажу для преподавателя введенного числового значения с одним из узлов дерева.
7)	Сохранение в строку в соответствии с заданным обходом. В зависимости от заданного обхода происходит рекурсивное заполнение либо сначала правой ветки, корня, потом левой ветки, либо сначала левой ветки, корня, потом правой ветки.
8)	Чтение из строки в соответствии с заданным обходом. Происходи рекурсивное чтение данных из узлов правой ветки, корня, затем левой ветки или левой ветки, корня, правой ветки.

Техническое задание:

1)	Создать заголовочный файл Header.h для нешаблонных классов и функций,Templ.h, файл с реализациями Main.cpp, файлы с реализацией шаблонных функций Templ_impl.h, ClassesRealiation.cpp, файл для пользовательского интерфейса user.h, файл с реализацией тестов Test.h.
2)	Объявить приватную структуру Node , в которая хранит содержимое узла дерева: данные, указатель на левого и правого потомка
3)	Создать класс Tree для реализации бинарного дерева. Данный класс хранит указатель на «голову» и  «хвост» списка, выбранный режим(подробнее ниже), количество элементов в списке. 
4)	Написать функции работы со студентами, преподавателями и функциями Add, ShowTree, map, where, MergeTrees, FindLittleTreeRoot, Search, FindNewRoot.

Пользовательский интерфейс:

В начале работы программы пользователь выбирает режим работы: включается либо тестовый режим, либо создаётся дерево с типом данных «Студент» и для него выполняются выше перечисленные операции, либо создается дерево с типом данных «Преподаватель», и для него так же выполняются выше перечисленные операции.
В режиме работы «Студент» и «Преподаватель» у пользователя есть возможность выбирать несколько раз выбирать тип функции. Выбор функции реализован в отдельной функции void start(int). Пользователь имеет возможность после выполнения одной функции, выбрать несколько раз другие варианты операций с деревом. В программе предусмотрена проверка корректности ввода данных, т.е. соответствие введённых данных числовому типу, а так же выход за диапазон допустимых значений.
Функция Add добавляет данные в соответствии с заданным обходом. Следует отметить, что для корректного выделения памяти и дальнейшей корректной работы с деревом сначала заполняется корень дерева, а только потом если обход ПКЛ, то сначала рекурсивно заполняется правая ветка, затем так же рекурсивно – левая ветка; если обход ЛКП, то сначала рекурсивно заполняется левая ветка, потом – правая.
Функция ShowTree если обход ПКЛ, то сначала рекурсивно выводится правая ветка, корень, левая ветка; если обход ЛКП, то сначала рекурсивно выводится левая ветка, корень, правая ветка. Узлы левых потомков выводятся в {}, правых потомков – в ||, корень не выделяется.
Функция  map заменяет все средние баллы студентов на 5, стаж преподавателей тоже на 5 и выводит получившееся дерево.
Функция where проверяет все элементы дерева на удовлетворение следующему условию: если средний балл(«Студент») или стаж («Преподаватель») больше 25, то этот элемент добавляется в новое дерево. На экран выводится новое дерево.
Функция MergeTrees. Для реализации данной функции создается новое дерево, ввод данных осуществляет пользователь. Отличие от создания основного дерева в том, что в этом случае пользователь задает количество и не задаёт тип обхода, поскольку обход устанавливается автоматически в соответствии с обходом основного дерева.
Функция FindLittleTreeRoot осуществляет поиск поддерева на вхождение. Следует сразу отметить, что если количество элементов нового дерева будет превышать количество элементов основного дерева, то программа будет запрашивать ввести то количество, которое не будет превышать число элементов основного дерева. Сначала программа проверяет существует ли в принципе в основном дереве с узлом, равным корню маленького дерева. Затем рекурсивно проверяется совпадение левых и правых потомков маленького дерева и элементов основного, начиная с узла, совпадающего с корнем маленького дерева.
Функция FindNewRoot осуществляет выделение поддерева по элементу. Пользователь вводит числовое значение, и если будет найден студент с таким средним баллом или преподаватель с таким стажем, то будет выделено поддерево. В противном случае выделение поддерева становится невозможным, о чем программа сообщает пользователю.
